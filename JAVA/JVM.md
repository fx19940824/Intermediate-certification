## Java技术体系
## 类文件结构 
## Java内存区域与内存溢出异常
## 虚拟机类加载机制
https://blog.51cto.com/u_14153136/3269717
(一)、类加载的时机

　　1、类的生命周期：类从被加载到虚拟机内存中开始，到卸载出内存为止。
2、需立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）的有且只有的5种请求：

　　　　① 遇到new、gerstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。

　　　　如：使用new关键字实例化对象时候，读取或设置一个类的静态字段（被final修饰，已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。

　　　　②使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

　　　　③当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

　　　　④当虚拟机启动时，用户需要指定一个要执行的主类（包括main（）方法的那个类），虚拟机会先初始化这个主流。

　　　　⑤当使用JDK1.7的动态语言支持时。

　　（二）、类加载的过程

　　类加载的全过程：加载、验证、准备、解析和初始化这五个阶段。　　

　　1、加载

　　“加载”是“类加载”过程的一个阶段。 

　　　① 通过一个类的全限定名来获取定义此类的二进制字节流（通过类加载实现）；

　　   ② 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；

　　　③ 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

 　　2、验证

　　连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

　　大致完成4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

　　3、准备

　　正式为变量分配内存并设置类变量初始值得阶段，这些变量所使用的内存都在方法区中进行分配。首先这个时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中，其次，这里所说的“初始值”通常情况下是数据类型的零值。

　　4、解析

　　解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

 

符号引用：符号应用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时无歧义地定位到目标即可，与虚拟机实现的内存布局无关，引用的目标并不一定以及加载到内存中。

直接引用：直接引用可以直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的。引用的目标必定已存在于内存中。

　　在16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所有虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用之前才去解析它。

　　解析动作主要针对类或接口、字段、类方法、方法类型、方法句柄和调用点限定符7类符号引用进行解析。

　　5、初始化　　

　　初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。

　　在准备阶段，变量已经赋过一次系统要求的初始值，而在初始阶段，则根据查询员通过查询制定的主观计划去初始化变量和其他资源，换而言之，初始化阶段是执行类类构造器<client>()方法的过程。

　　在<client>（）方法中，静态语句块中只能访问到定义在静态语句块之前的变量，定义在他之后的变量，在前面的静态语句块可以赋值，但不能访问。
## 垃圾收集器与内存分配策略
## 虚拟机性能监控
## 故障处理工具
